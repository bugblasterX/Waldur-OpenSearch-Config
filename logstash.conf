input {
# Exec runs our python script which fetches the data from our API endpoint and prints to stdout, which logstash ingests.
exec {
    command => "python3  /usr/share/logstash/python_event_script.py"
    interval => 60  # Run the script every 60 seconds (1 minutes)
    codec => "json"
  }


 # Periodic Http Poller to get events for alert triggers, body contains query for resource creation/update/deletion.
  http_poller {
    urls => {
      test_data => {
        method => get
        url => "https://opensearch-node1:9200/logging_event_business/_search"
        user => "${OPENSEARCH_USER}"
        password => "${OPENSEARCH_PASSWORD}"
	headers => {
          "Content-Type" => "application/json"
        }
        body => '{
  "size": 0,
  "query": {
    "bool": {
      "must": [
        {
          "range": {
            "@timestamp": {
              "gte": "now-15m/m",
              "lte": "now"
            }
          }
        },
        {
          "terms": {
            "event_type": ["resource_creation_succeeded", "resource_update_succeeded","resource_deletion_succeeded"]
          }
        }
      ]
    }
  },
  "aggs": {
    "resource_creation_succeeded": {
      "filter": {
        "term": { "event_type": "resource_creation_succeeded" }
      },
      "aggs": {
        "resource_count": {
          "terms": {
            "field": "context.project_uuid.keyword",
            "size": 10000
          },
          "aggs": {
            "total_resources": {
              "value_count": {
                "field": "context.project_uuid.keyword"
              }
            },
            "project_filter": {
              "bucket_selector": {
                "buckets_path": {
                  "totalResources": "total_resources"
                },
                "script": "params.totalResources > 10"
              }
            }
          }
        }
      }
    },
    "resource_update_succeeded": {
      "filter": {
        "term": { "event_type": "resource_update_succeeded" }
      },
      "aggs": {
        "update_count": {
          "terms": {
            "field": "context.project_uuid.keyword",
            "size": 10000
          },
          "aggs": {
            "total_updates": {
              "value_count": {
                "field": "context.project_uuid.keyword"
              }
            },
            "user_filter": {
              "bucket_selector": {
                "buckets_path": {
                  "totalUpdates": "total_updates"
                },
                "script": "params.totalUpdates > 6"
              }
            }
          }
        }
      }
    },
     "resource_deletion_succeeded": {
      "filter": {
        "term": { "event_type": "resource_deletion_succeeded" }
      },
      "aggs": {
        "delete_count": {
          "terms": {
            "field": "context.project_uuid.keyword",
            "size": 10000
          },
          "aggs": {
            "total_deletes": {
              "value_count": {
                "field": "context.project_uuid.keyword"
              }
            },
            "user_filter": {
              "bucket_selector": {
                "buckets_path": {
                  "totalDeletes": "total_deletes"
                },
                "script": "params.totalDeletes > 6"
              }
            }
          }
        }
      }
    }
  }
}'
      }
    }
    schedule => { cron => "*/14 * * * * UTC"}
    codec => "json"
    ssl_verification_mode => none
    target => "opensearch_resource_data"  # Store fetched data in a separate field
  }

}


filter {

  if [opensearch_resource_data] {
ruby {
    code => '
      require "securerandom"
      require "time"

      aggregations = event.get("[opensearch_resource_data][aggregations]")

      aggregations.each do |agg_name, aggregation|
        case agg_name
        when "resource_creation_succeeded"
          buckets_path = "[opensearch_resource_data][aggregations][#{agg_name}][resource_count][buckets]"
          message = "More than 10 resources created in a short time span for project"
          event_type = "resource_creation_exceeded"
        when "resource_deletion_succeeded"
          buckets_path = "[opensearch_resource_data][aggregations][#{agg_name}][delete_count][buckets]"
          message = "More than 10 resources deleted in a short time span for project"
          event_type = "resource_deletion_exceeded"
        when "resource_update_succeeded"
          buckets_path = "[opensearch_resource_data][aggregations][#{agg_name}][update_count][buckets]"
          message = "More than 10 resources updated in a short time span for project"
          event_type = "resource_update_exceeded"
        else
          next  
        end
        
        buckets = event.get(buckets_path)

        if buckets && !buckets.empty?
          buckets.each do |bucket|
            if bucket["doc_count"] > 0
              new_event = LogStash::Event.new(
                "project_uuid" => bucket["key"],
                "created" => Time.now.utc.iso8601,
                "event_type" => event_type,
                "message" => message,
                "uuid" => SecureRandom.uuid
              )
              new_event_block.call(new_event)
            end
          end
        end
      end

      event.cancel
    '
  }
}


  mutate {
    remove_field => ["opensearch_parsed_resource_data", "opensearch_resource_data", "[process][exit_code]", "[event][original]", "[process][command_line]"]
  }

  mutate {
    replace => { "[context][ip_address]" => "190.50.12.89432" }
  }
  date {
    match => ["created", "ISO8601"]
  }
  age {}

#  if [@metadata][age] > 300 {
#    drop {}
#  }

  if [event_type] == "auth_logged_in_with_username" {

    http {
      url => "https://opensearch-node1:9200/logging_event_business/_search"
      verb => "GET"
      ssl_verification_mode => none
      user => "${OPENSEARCH_USER}"
      password => "${OPENSEARCH_PASSWORD}"
      body => '{"query":{"bool":{"must":[{"term":{"context.ip_address":"%{[context][ip_address]}"}}]}},"size":0}'
      body_format => "json"
      target_body => "opensearch_response"
    }

  ruby {
    code => "
      if event.get('[opensearch_response][hits][total][value]').to_i == 0
        event.set('new_ip', 'True')
      else
        event.set('new_ip', 'False')
      end
      event.remove('opensearch_response')
      "
    }

  }

  if [context][user_uuid] {
 
   http {
      url => "https://opensearch-node1:9200/logging_event_business/_search"
      verb => "GET"
      ssl_verification_mode => none
      user => "${OPENSEARCH_USER}"
      password => "${OPENSEARCH_PASSWORD}"
      body => '{"size": 0,"query": {"bool": {"must": [{"exists": {"field": "context.user_uuid","boost": 1}},{"range": {"created": {"from": "now-50m/m","to": "now/m","include_lower": true,"include_upper": false,"boost": 1}}},{"term": {"context.user_uuid":  "%{[context][user_uuid]}"}}],"adjust_pure_negative": true,"boost": 1}},"aggregations": {"multiple_ips": {"cardinality": {"field": "context.ip_address.keyword"}}}} '
      body_format => "json"
      target_body => "multiple_ip_response"
    }

  ruby {
    code => "
      if event.get('[multiple_ip_response][aggregations][multiple_ips][value]').to_i > 1
        event.set('multiple_ip_detected', 'True')
      else
        event.set('multiple_ip_detected', 'False')
      end
      event.remove('multiple_ip_response')
    "
  }

}

}



output {

     stdout { codec => rubydebug
      { metadata => true }
    }
  opensearch {
    hosts => ["https://opensearch-node1:9200","https://opensearch-node2:9200"]
    user => "${OPENSEARCH_USER}"
    password => "${OPENSEARCH_PASSWORD}"
    ssl_certificate_verification => false
    #index => "logstash-logs-%{+YYYY.MM.dd}"
    index => "logging_event_business"
    document_id => "%{[uuid]}"
    action => "create"
  }
}
